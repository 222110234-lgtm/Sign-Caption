<!DOCTYPE html>
<html>
<head>
    <title>Sign Language Translator - Backend Linked</title>
    <style>
        body { font-family: sans-serif; display: flex; flex-direction: column; align-items: center; }
        #video { transform: scaleX(-1); border: 2px solid black; }
        #prediction-box { font-size: 2em; margin-top: 20px; color: blue; }
        .status { font-size: 0.9em; color: gray; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Real-time Sign Language Translator</h1>
    <video id="video" width="640" height="480" autoplay playsinline></video>
    <p id="prediction-box">...</p>
    <p class="status" id="status">Connecting to backend...</p>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

        const video = document.getElementById('video');
        const predictionBox = document.getElementById('prediction-box');
        const statusBox = document.getElementById('status');
        let handLandmarker;
        let lastVideoTime = -1;
        let sequence = [];
        const SEQUENCE_LENGTH = 30;
        let predictionTimeout;

        // Backend URL - can be configured via window.BACKEND_URL or defaults to localhost:8080
        const BACKEND_URL = window.BACKEND_URL || 'http://localhost:8080';

        // ---  INITIALIZE MEDIAPIPE ---
        async function createHandLandmarker() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { 
                    // *** THIS IS THE FINAL CORRECTED URL ***
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, 
                    delegate: "GPU" 
                },
                runningMode: "VIDEO",
                numHands: 1
            });
            statusBox.textContent = `Backend: ${BACKEND_URL}`;
            startWebcam();
        }
        createHandLandmarker();

        // --- START WEBCAM ---
        function startWebcam() {
            navigator.mediaDevices.getUserMedia({ video: true })
                .then(stream => {
                    video.srcObject = stream;
                    video.addEventListener('loadeddata', predictWebcam);
                });
        }

        // --- PREDICTION LOOP ---
        function predictWebcam() {
            if (video.currentTime !== lastVideoTime) {
                const results = handLandmarker.detectForVideo(video, Date.now());
                lastVideoTime = video.currentTime;

                if (results.landmarks && results.landmarks.length > 0) {
                    const landmarks = results.landmarks[0].flatMap(lm => [lm.x, lm.y, lm.z]);
                    sequence.push(landmarks);

                    if (sequence.length === SEQUENCE_LENGTH) {
                        sendForPrediction(sequence);
                        sequence = []; 
                    }
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        // --- SEND DATA TO BACKEND API (Node.js Backend) ---
        async function sendForPrediction(landmarkData) {
            try {
                const response = await fetch(`${BACKEND_URL}/api/predictions/predict`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ landmarks: landmarkData })
                });
                
                if (!response.ok) {
                    throw new Error(`Backend error: ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.ok && result.prediction) {
                    predictionBox.textContent = result.prediction;
                    statusBox.textContent = `Backend: ${BACKEND_URL} ✓`;
                } else {
                    predictionBox.textContent = result.error || "Prediction failed";
                    statusBox.textContent = `Backend: ${BACKEND_URL} ✗`;
                }
                
                clearTimeout(predictionTimeout);
                predictionTimeout = setTimeout(() => {
                    predictionBox.textContent = "...";
                }, 2000);

            } catch (error) {
                console.error("Error sending data for prediction:", error);
                predictionBox.textContent = "Error: Check backend connection";
                statusBox.textContent = `Backend: ${BACKEND_URL} ✗ Connection failed`;
                setTimeout(() => {
                    predictionBox.textContent = "...";
                }, 2000);
            }
        }
    </script>
</body>
</html>

