<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>collection - Backend Linked</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif, system-ui;
        }
        .container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #1a1a1a;
        }
        #webcam {
            border-radius: 10px;
            border: 2px solid #333;
        }
        #output {
            color: white;
            font-size: 1.5rem; /* Smaller font for status messages */
            text-align: center;
            margin-top: 15px;
            min-height: 40px;
            font-weight: 500;
        }
        #prediction-output {
            color: #34d399;
            font-size: 2rem;
            text-align: center;
            margin-top: 15px;
            min-height: 50px;
            font-weight: 600;
        }
        .btn {
            border: none;
            color: white;
            padding: 12px 28px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 1rem;
            font-weight: 500;
            margin: 10px 5px;
            cursor: pointer;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.1s;
        }
        .btn-start { background-color: #16a34a; /* Green */ }
        .btn-start:hover { background-color: #15803d; }
        .btn-stop { background-color: #dc2626; /* Red */ }
        .btn-stop:hover { background-color: #b91c1c; }
        .btn-download { background-color: #0e7490; /* Cyan */ }
        .btn-download:hover { background-color: #155e75; }
        .btn-predict { background-color: #9333ea; /* Purple */ }
        .btn-predict:hover { background-color: #7e22ce; }
        .btn:active { transform: scale(0.98); }
        .btn:disabled {
            background-color: #4b5563;
            color: #9ca3af;
            cursor: not-allowed;
        }
        .input-label {
            padding: 10px;
            font-size: 1.2rem;
            border-radius: 8px;
            border: 2px solid #4b5563;
            background-color: #374151;
            color: white;
            text-align: right;
            margin-bottom: 10px;
            width: 100%;
        }
    </style>
</head>
<body class="bg-gray-900">
    <div class="container flex-col p-4 max-w-3xl mx-auto">
        <div class="relative shadow-lg rounded-lg w-full">
            <video id="webcam" class="transform -scale-x-100 w-full" autoplay playsinline></video>
            <canvas id="canvas" class="absolute top-0 left-0 w-full h-full"></canvas>
        </div>
        
        <div class="w-full mt-4">
            <label for="signLabel" class="text-white text-lg mb-2 block">الكلمة المرتبطة بالإشارة:</label>
            <input type="text" id="signLabel" class="input-label" placeholder="مثال: مرحبا">
        </div>

        <div class="flex flex-wrap">
            <button id="startBtn" class="btn btn-start" disabled>تحميل النموذج...</button>
            <button id="stopBtn" class="btn btn-stop" disabled>إيقاف التسجيل</button>
            <button id="downloadBtn" class="btn btn-download" disabled>تنزيل البيانات</button>
            <button id="predictBtn" class="btn btn-predict" disabled>اختبار التنبؤ</button>
        </div>
        <div id="output">جاهز لبدء جمع البيانات.</div>
        <div id="prediction-output"></div>
    </div>

    <script type="module">
        import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0";

        const video = document.getElementById('webcam');
        const canvas = document.getElementById('canvas');
        const output = document.getElementById('output');
        const predictionOutput = document.getElementById('prediction-output');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const predictBtn = document.getElementById('predictBtn');
        const signLabelInput = document.getElementById('signLabel');
        const ctx = canvas.getContext('2d');

        // Backend URL - can be configured via window.BACKEND_URL or defaults to localhost:8080
        const BACKEND_URL = window.BACKEND_URL || 'http://localhost:8080';

        let handLandmarker;
        let lastVideoTime = -1;
        let isRecording = false;
        let isPredicting = false;
        let landmarkSequence = [];
        let collectedData = [];
        let predictionSequence = [];
        const PREDICTION_SEQUENCE_LENGTH = 30;
        let predictionTimeout;

        async function setup() {
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task",
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numHands: 2
            });
            
            output.textContent = 'النموذج جاهز.';
            startBtn.textContent = 'بدء التسجيل';
            startBtn.disabled = false;
            predictBtn.disabled = false;

            navigator.mediaDevices.getUserMedia({ video: true }).then(stream => {
                video.srcObject = stream;
                video.addEventListener('loadeddata', predictWebcam);
            });
        }
        
        startBtn.addEventListener('click', () => {
            const label = signLabelInput.value.trim();
            if (!label) {
                output.textContent = 'الرجاء إدخال كلمة للإشارة قبل التسجيل.';
                return;
            }
            isRecording = true;
            landmarkSequence = [];
            output.textContent = `تسجيل الحركة لكلمة "${label}"...`;
            startBtn.disabled = true;
            stopBtn.disabled = false;
            downloadBtn.disabled = true;
            predictBtn.disabled = true;
            signLabelInput.disabled = true;
        });

        stopBtn.addEventListener('click', () => {
            isRecording = false;
            const label = signLabelInput.value.trim();
            
            if (landmarkSequence.length > 10) {
                 collectedData.push({ label: label, data: landmarkSequence });
                 output.textContent = `تم تسجيل ${collectedData.length} عينة. جاهز للتسجيل التالي.`;
            } else {
                output.textContent = 'التسجيل قصير جدًا، لم يتم الحفظ. حاول مرة أخرى.';
            }
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            downloadBtn.disabled = false;
            predictBtn.disabled = false;
            signLabelInput.disabled = false;
        });

        downloadBtn.addEventListener('click', () => {
            if (collectedData.length === 0) {
                output.textContent = 'لا توجد بيانات مسجلة لتنزيلها.';
                return;
            }

            const jsonString = JSON.stringify(collectedData, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", url);
            downloadAnchorNode.setAttribute("download", "sign_language_data.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();

            URL.revokeObjectURL(url);
            
            output.textContent = `تم تنزيل ${collectedData.length} عينة بنجاح.`;
        });

        predictBtn.addEventListener('click', () => {
            if (isPredicting) {
                isPredicting = false;
                predictBtn.textContent = 'اختبار التنبؤ';
                predictionOutput.textContent = '';
                output.textContent = 'تم إيقاف التنبؤ.';
            } else {
                isPredicting = true;
                predictionSequence = [];
                predictBtn.textContent = 'إيقاف التنبؤ';
                output.textContent = 'جاري التنبؤ...';
            }
        });

        async function sendForPrediction(landmarkData) {
            try {
                // Convert landmarks to flat array format expected by the model
                const flatLandmarks = landmarkData.map(frame => {
                    if (Array.isArray(frame[0])) {
                        // Multiple hands - flatten all hands
                        return frame.flatMap(hand => hand.flatMap(lm => [lm.x, lm.y, lm.z]));
                    } else {
                        // Single hand
                        return frame.flatMap(lm => [lm.x, lm.y, lm.z]);
                    }
                });

                const response = await fetch(`${BACKEND_URL}/api/predictions/predict`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ landmarks: flatLandmarks })
                });

                if (!response.ok) {
                    throw new Error(`Backend error: ${response.status}`);
                }

                const result = await response.json();
                
                if (result.ok && result.prediction) {
                    predictionOutput.textContent = `التنبؤ: ${result.prediction}`;
                } else {
                    predictionOutput.textContent = result.error || "فشل التنبؤ";
                }

            } catch (error) {
                console.error("Error sending data for prediction:", error);
                predictionOutput.textContent = "خطأ: تحقق من اتصال الخادم";
            }
        }

        async function predictWebcam() {
            const videoRatio = video.videoHeight / video.videoWidth;
            video.style.height = video.offsetWidth * videoRatio + 'px';
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            
            ctx.save();
            ctx.scale(-1, 1);
            ctx.translate(-canvas.width, 0);
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            ctx.restore();

            if (lastVideoTime !== video.currentTime) {
                lastVideoTime = video.currentTime;
                const results = handLandmarker.detectForVideo(video, Date.now());

                if (results.landmarks && results.landmarks.length > 0) {
                    for (const landmarks of results.landmarks) {
                        drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, ctx, canvas.width, canvas.height);
                        drawLandmarks(landmarks, ctx, canvas.width, canvas.height);
                    }
                    
                    if (isRecording) {
                        // Save the raw landmark data, which is perfect for training
                        const frameLandmarks = results.landmarks.map(hand => hand.map(lm => ({ x: lm.x, y: lm.y, z: lm.z })));
                        landmarkSequence.push(frameLandmarks);
                    }
                    
                    if (isPredicting) {
                        // Collect landmarks for prediction
                        const frameLandmarks = results.landmarks.map(hand => hand.map(lm => ({ x: lm.x, y: lm.y, z: lm.z })));
                        predictionSequence.push(frameLandmarks);
                        
                        if (predictionSequence.length >= PREDICTION_SEQUENCE_LENGTH) {
                            sendForPrediction(predictionSequence);
                            predictionSequence = [];
                        }
                    }
                }
            }
            window.requestAnimationFrame(predictWebcam);
        }

        function drawConnectors(landmarks, connectors, targetCtx, width, height) {
            targetCtx.strokeStyle = `rgba(52, 211, 153, 1.0)`; // Green
            targetCtx.lineWidth = 5;
            for (const connection of connectors) {
                const start = landmarks[connection.start];
                const end = landmarks[connection.end];
                targetCtx.beginPath();
                targetCtx.moveTo(start.x * width, start.y * height);
                targetCtx.lineTo(end.x * width, end.y * height);
                targetCtx.stroke();
            }
        }

        function drawLandmarks(landmarks, targetCtx, width, height) {
            targetCtx.fillStyle = `rgba(239, 68, 68, 1.0)`; // Red
            for (const landmark of landmarks) {
                targetCtx.beginPath();
                targetCtx.arc(landmark.x * width, landmark.y * height, 5, 0, 2 * Math.PI);
                targetCtx.fill();
            }
        }
        
        setup();
    </script>
</body>
</html>

